Ta fonction doit faire :
A. RÃ©cupÃ©rer tous les mouvements possibles

Les 4 directions autour de la tÃªte
Ã‰liminer ceux qui sortent du plateau
Ã‰liminer ceux qui touchent le corps du snake
(Tu as dÃ©jÃ  Ã§a dans ta fonction survive())

B. Pour CHAQUE mouvement possible, calculer 4 scores :
Score 1 : Suivre la queue ðŸŽ¯

Calculer la distance entre le mouvement candidat et la queue du snake (dernier segment)
Plus la distance est petite = meilleur score
Tu peux utiliser la distance de Manhattan : abs(x1-x2) + abs(y1-y2)
Normaliser le score (par exemple : score = 100 / (distance + 1))

Score 2 : Maximiser l'espace libre ðŸ“¦

Depuis le mouvement candidat, compter combien de cases libres sont accessibles
2 faÃ§ons de faire :

Simple : compter juste les 4 voisins directs qui sont libres
Plus complexe : faire un mini flood-fill pour compter toutes les cases accessibles dans un rayon


Plus il y a d'espace = meilleur score

Score 3 : Rester proche de la nourriture ðŸŽ

Calculer la distance entre le mouvement candidat et la nourriture
Plus on est proche = meilleur score
Utiliser distance de Manhattan
Normaliser : score = 100 / (distance + 1)

Score 4 : Ã‰viter les impasses ðŸšª

Depuis le mouvement candidat, compter combien de mouvements seraient possibles au tour SUIVANT
Simuler : si je vais lÃ , combien d'options j'aurai aprÃ¨s ?
Plus d'options = meilleur score
score = nombre_options Ã— 25 (par exemple)

Score_final = (0.45 Ã— score_queue) 
            + (0.25 Ã— score_espace) 
            + (0.20 Ã— score_nourriture) 
            + (0.10 Ã— score_impasse)
```

**D. Retourner le mouvement avec le meilleur score final**

---

## **Ã‰TAPE 3 : Structure de ta fonction**

Ta fonction devrait ressembler Ã  Ã§a (en pseudo-code) :
```
fonction mode_survie_intelligent(position_tete, corps_snake, position_nourriture):
    
    # A. RÃ©cupÃ©rer mouvements possibles
    mouvements_possibles = get_mouvements_valides()
    
    # Si aucun mouvement possible â†’ game over
    si mouvements_possibles est vide:
        retourner None
    
    # B. Ã‰valuer chaque mouvement
    meilleur_mouvement = None
    meilleur_score = -infini
    
    pour chaque mouvement dans mouvements_possibles:
        # Calculer les 4 scores
        score1 = calculer_score_queue(mouvement, queue_snake)
        score2 = calculer_score_espace(mouvement, corps_snake)
        score3 = calculer_score_nourriture(mouvement, position_nourriture)
        score4 = calculer_score_options(mouvement, corps_snake)
        
        # Score composite
        score_final = 0.45*score1 + 0.25*score2 + 0.20*score3 + 0.10*score4
        
        # Garder le meilleur
        si score_final > meilleur_score:
            meilleur_score = score_final
            meilleur_mouvement = mouvement
    
    # C. Retourner le meilleur
    retourner meilleur_mouvement